<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CVE-2015-3636 · Arvin.X's Blog</title><meta name="description" content="CVE-2015-3636 - Arvin.X"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://a7vinx.github.io/atom.xml" title="Arvin.X's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/a7vinx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">CVE-2015-3636</h1><div class="post-info">Dec 4, 2016</div><div class="post-content"><p>CVE-2015-3636，由Keen Team发现的Linux内核UAF漏洞（Keen Team的paper：<a href="https://www.blackhat.com/docs/us-15/materials/us-15-Xu-Ah-Universal-Android-Rooting-Is-Back-wp.pdf" target="_blank" rel="external">Own your Android! Yet Another Universal Root</a>），可以用来提权，但是在x86_64上只能导致内核panic。影响范围为4.0.3以下的Linux内核，可用于Android 6.0以下的系统Root。</p>
<a id="more"></a>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>具体的漏洞成因paper中已经讲得很清楚了，原因就是net/ipv4/ping.c中的ping_unhash函数对于hlist node的错误处理，没有将pprev置NULL导致sokcet中的sk可被free进而导致UAF。这里主要再记录一些poc触发流程的分析。</p>
<p>在socket相关的代码中，有几个结构体对于理解比较关键，首先是struct socket中的ops指针指向的struct proto_ops和struct sock中的sk_prot指向的struct proto，前者代表当前socke所暴露出的对socket的操作接口，后者是针对某一协议的具体操作实现，ops一般都是简单包装后调用对应的sk_prot中的函数，两者通过inetsw_array数组来完成组合，像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1016</span>     &#123;</div><div class="line"><span class="number">1017</span>         .type =       SOCK_DGRAM,</div><div class="line"><span class="number">1018</span>         .protocol =   IPPROTO_UDP,</div><div class="line"><span class="number">1019</span>         .prot =       &amp;udp_prot,</div><div class="line"><span class="number">1020</span>         .ops =        &amp;inet_dgram_ops,</div><div class="line"><span class="number">1021</span>         .no_check =   UDP_CSUM_DEFAULT,</div><div class="line"><span class="number">1022</span>         .flags =      INET_PROTOSW_PERMANENT,</div><div class="line"><span class="number">1023</span>        &#125;,</div><div class="line"><span class="number">1024</span> </div><div class="line"><span class="number">1025</span>        &#123;</div><div class="line"><span class="number">1026</span>         .type =       SOCK_DGRAM,</div><div class="line"><span class="number">1027</span>         .protocol =   IPPROTO_ICMP,</div><div class="line"><span class="number">1028</span>         .prot =       &amp;ping_prot,</div><div class="line"><span class="number">1029</span>         .ops =        &amp;inet_dgram_ops,</div><div class="line"><span class="number">1030</span>         .no_check =   UDP_CSUM_DEFAULT,</div><div class="line"><span class="number">1031</span>         .flags =      INET_PROTOSW_REUSE,</div><div class="line"><span class="number">1032</span>        &#125;,</div></pre></td></tr></table></figure>
<p>对于ping协议来说，涉及的就是ping_prot与inet_dgram_ops。还有就是struct net_proto_family，这个结构体只有三个成员，其中就包含了对应协议族的socket所用的create函数指针，在其中会完成ops和sk_prot指针的初始化。</p>
<p>漏洞的主要目的在于将sk对象的refcnt减为零从而触发free，同时还必须要先把这个sk hash一次，这样才能进入if(sk_hashed(sk))后面的逻辑中去。而这个hash过程，跟进去具体看一下可以知道，主要就是把目标socket和端口号建立个联系（所以之后对next的pprev指针的操作是不用担心稳定性问题的，一开始还有些疑惑orz）。</p>
<p>关于refcnt的操作，在一开始创建socket的时候，会从sys_socketcall一路调用到inet_create来创建AF_INET对应的socket，并在inet_create中调用sock_init_data，其中使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2130</span>     atomic_set(&amp;sk-&gt;sk_refcnt, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>初始化refcnt为1。</p>
<p>关于hash的操作，对于ping协议来说，不是在相对应的ping_hash中做的，ping_hash中什么也没有，而是在ops中的inet_dgram_connect中完成的。具体地是由调用inet_autobind再调用sk_prot中的get_port，在其中完成refcnt++以及hash操作。</p>
<p>所以这样看下来，最快的触发UAF的方式就是先create socket，此时refcnt=1，然后正常connect，此时refcnt=2并且完成hash，然后就可以两次触发disconnect使refcnt=0触发free了。</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>具体的漏洞利用思路Keen Team也已经在paper中很好地秀给我们了，在这里还是记录一些实践中的坑点或是收获。</p>
<ul>
<li>关于结构体偏移，可以使用gdb来看：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) p &amp;(((strcut sock *)<span class="number">0</span>))-&gt;sk_stamp)</div></pre></td></tr></table></figure>
<ul>
<li>关于mc_list，在利用中除了直接覆写sk_prot中的函数指针外，还有一个检查点要过，在inet_release中调用的ip_mc_drop_socket，如果mc_list成员为NULL可以直接从这里出去：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">2286</span> <span class="function"><span class="keyword">void</span> <span class="title">ip_mc_drop_socket</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span>                                                                                                       </span></div><div class="line">2287 &#123;       </div><div class="line"><span class="number">2288</span>     <span class="keyword">struct</span> inet_sock *inet = inet_sk(sk);</div><div class="line"><span class="number">2289</span>     <span class="keyword">struct</span> ip_mc_socklist *iml;</div><div class="line"><span class="number">2290</span>     <span class="keyword">struct</span> net *net = sock_net(sk);</div><div class="line"><span class="number">2291</span> </div><div class="line"><span class="number">2292</span>     <span class="keyword">if</span> (inet-&gt;mc_list == <span class="literal">NULL</span>)</div><div class="line"><span class="number">2293</span>         <span class="keyword">return</span>;</div><div class="line"><span class="number">2294</span> </div><div class="line">...		 [...]</div></pre></td></tr></table></figure>
<ul>
<li>关于JOP链，一开始找的时候执着于找到paper中的core gadget，想着能够复用gadget可以省事，结果还不如直接找更快些，真的是被恶心到了…</li>
<li>关于确认task_struct位置，可以利用task_struct中的三个cpu_timers的next和prev指针相同以及real_cred与cred相同的特性来避免硬编码offset，提高exp的通用性。</li>
<li>关于绕过SELinux，Keen Team的另一个slide：<a href="http://www.slideshare.net/jiahongfang5/mosec2015-jfang" target="_blank" rel="external">How to Root 10 Million Phones with One Exploit</a>    也详细讲述了利用思路，真是让人陶醉。</li>
<li>可实际上即便拿到了u:r:init:s0的context，却依然是受到限制的，这里还需要继续研究</li>
</ul>
<p>最后分享一句在看Android的sepolicy文件时看到的注释，看得我害怕地躲在角落瑟瑟发抖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">65 # - You are running an exploit which switched to the init task credentials</div><div class="line">66 #   and is then trying to exec a shell or other program.  You lose!</div></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/02/cve_2015_7547/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://a7vinx.github.io">Arvin.X</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>