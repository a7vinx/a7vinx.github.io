<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CVE-2015-7547 · Arvin.X's Blog</title><meta name="description" content="CVE-2015-7547 - Arvin.X"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://a7vinx.github.io/atom.xml" title="Arvin.X's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/a7vinx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">CVE-2015-7547</h1><div class="post-info">Nov 2, 2016</div><div class="post-content"><p>CVE-2015-7547，由google安全团队披露的glibc中getaddrinfo()函数产生的stack overflow漏洞，影响glibc版本2.9-2.22，产生漏洞的原因在于getaddrinfo在进行DNS查询的过程中，调用到send_dg()或者send_vc()的时候，由于逻辑错误导致标识buffer大小的变量和buffer的实际大小出现了不统一，进一步导致stack-overflow的发生。</p>
<a id="more"></a>
<p><a href="https://github.com/fjserna/CVE-2015-7547" target="_blank" rel="external">这里</a>有google团队给出的POC，但是保留了EXP——“We will not release our exploit code, but a non-weaponized Proof of Concept has been made available simultaneously with this blog post”。经过分析来看RCE是可行的，但是还需要去绕过一些保护机制和check。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这个用户态的漏洞还是比较好复现的。首先我们需要获取一份未patch的存在漏洞的glibc，可以从<a href="http://mirror.hust.edu.cn/gnu/libc/" target="_blank" rel="external">GNU站点</a>中下载，然后编译安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tar zxvf glibc-2.19.tar.gz </div><div class="line"><span class="built_in">cd</span> /glibc-2.19</div><div class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</div><div class="line">../configure --prefix=/usr/<span class="built_in">local</span>/glibc219/ --enable-debug CFLAGS=<span class="string">"-g -O1"</span> CPPFLAGS=<span class="string">"-g -O1"</span></div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>在google给出的poc中，一份python用来监控53端口模拟DNS服务器以产生构造的DNS响应包，另一份client简单调用getaddrinfo函数触发漏洞。</p>
<p>我们需要将google给出的poc中的client使用存在漏洞的glibc进行编译，需要参数rpath和dynamic-linker来指定glibc与对应的ld-linux：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-Wl,-rpath=/path/to/new/glibc/lib</div><div class="line">-Wl,-dynamic-linker=/path/to/newglibc/ld-linux.so.2</div></pre></td></tr></table></figure>
<p>然后修改本地dns服务器为127.0.0.1，对应的配置文件为/etc/resolv.conf。之后分别启动python文件和client，就可以看到崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@Tencent1:~/CVE-2015-7547$ ./client</div><div class="line">Segmentation fault</div></pre></td></tr></table></figure>
<p>可以用gdb确认一下崩溃位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">root@Tencent1:~/CVE-2015-7547$ gdb client </div><div class="line">GNU gdb (Debian 7.11.1-2) 7.11.1</div><div class="line">Copyright (C) 2016 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from client...(no debugging symbols found)...done.</div><div class="line">gdb-peda$ r</div><div class="line">Starting program: /root/CVE-2015-7547/client </div><div class="line"></div><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line"> [----------------------------------registers-----------------------------------]</div><div class="line">RAX: 0x7fffffffe2a8 (&apos;B&apos; &lt;repeats 150 times&gt;, &quot;lrouters&quot;)</div><div class="line">RBX: 0x4242424242424242 (&apos;BBBBBBBB&apos;)</div><div class="line">RCX: 0xffffffffffffffff </div><div class="line">RDX: 0x4242424242424242 (&apos;BBBBBBBB&apos;)</div><div class="line">RSI: 0x0 </div><div class="line">RDI: 0xffffffff </div><div class="line">RBP: 0x7fffffffd0b0 --&gt; 0x7ffff7ddc080 --&gt; 0x200000001 </div><div class="line">RSP: 0x7fffffffcde0 --&gt; 0x1000001045e </div><div class="line">RIP: 0x7ffff741986c (&lt;__GI___libc_res_nquery+1084&gt;:     movzx  eax,BYTE PTR [rbx+0x3])</div><div class="line">R8 : 0x24 (&apos;$&apos;)</div><div class="line">R9 : 0x7fffffffcc68 --&gt; 0x7fffffffda40 --&gt; 0x424242424242de8c </div><div class="line">R10: 0x7fffffffc610 --&gt; 0x0 </div><div class="line">R11: 0x206 </div><div class="line">R12: 0xbcc </div><div class="line">R13: 0x7fffffffe2b0 (&apos;B&apos; &lt;repeats 142 times&gt;, &quot;lrouters&quot;)</div><div class="line">R14: 0x24 (&apos;$&apos;)</div><div class="line">R15: 0x7ffff7ddc080 --&gt; 0x200000001</div><div class="line">EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)</div><div class="line">[-------------------------------------code-------------------------------------]</div><div class="line">   0x7ffff7419859 &lt;__GI___libc_res_nquery+1065&gt;:        lea    rsi,[rip+0x8b29]        # 0x7ffff7422389</div><div class="line">   0x7ffff7419860 &lt;__GI___libc_res_nquery+1072&gt;:        lea    rdi,[rip+0x8b81]        # 0x7ffff74223e8</div><div class="line">   0x7ffff7419867 &lt;__GI___libc_res_nquery+1079&gt;:        call   0x7ffff7415820 &lt;__assert_fail@plt&gt;</div><div class="line">=&gt; 0x7ffff741986c &lt;__GI___libc_res_nquery+1084&gt;:        movzx  eax,BYTE PTR [rbx+0x3]</div><div class="line">   0x7ffff7419870 &lt;__GI___libc_res_nquery+1088&gt;:        and    eax,0xf</div><div class="line">   0x7ffff7419873 &lt;__GI___libc_res_nquery+1091&gt;:        jne    0x7ffff7419a5f &lt;__GI___libc_res_nquery+1583&gt;</div><div class="line">   0x7ffff7419879 &lt;__GI___libc_res_nquery+1097&gt;:        movzx  ecx,WORD PTR [rbx+0x6]</div><div class="line">   0x7ffff741987d &lt;__GI___libc_res_nquery+1101&gt;:        ror    cx,0x8</div><div class="line">[------------------------------------stack-------------------------------------]</div><div class="line">0000| 0x7fffffffcde0 --&gt; 0x1000001045e </div><div class="line">0008| 0x7fffffffcde8 --&gt; 0x6f6f660300000000 </div><div class="line">0016| 0x7fffffffcdf0 --&gt; 0x6f6f670672616203 </div><div class="line">0024| 0x7fffffffcdf8 --&gt; 0x6d6f6303656c67 </div><div class="line">0032| 0x7fffffffce00 --&gt; 0x1de8c01000100 </div><div class="line">0040| 0x7fffffffce08 --&gt; 0x100 </div><div class="line">0048| 0x7fffffffce10 --&gt; 0x726162036f6f6603 </div><div class="line">0056| 0x7fffffffce18 --&gt; 0x3656c676f6f6706 </div><div class="line">[------------------------------------------------------------------------------]</div><div class="line">Legend: code, data, rodata, value</div><div class="line">Stopped reason: SIGSEGV</div><div class="line">__GI___libc_res_nquery (statp=statp@entry=0x7ffff7ddc080 &lt;_res@GLIBC_2.2.5&gt;, name=0x400717 &quot;foo.bar.google.com&quot;, class=class@entry=0x1, </div><div class="line">    type=type@entry=0xf371, answer=answer@entry=0x7fffffffda40 &quot;\214\336&quot;, &apos;B&apos; &lt;repeats 198 times&gt;..., anslen=anslen@entry=0x800, </div><div class="line">    answerp=0x7fffffffe2b0, answerp2=0x7fffffffe2a8, nanswerp2=0x7fffffffe2a4, resplen2=0x7fffffffe2a0) at res_query.c:262</div><div class="line">262             if ((hp-&gt;rcode != NOERROR || ntohs(hp-&gt;ancount) == 0)</div><div class="line">gdb-peda$ bt</div><div class="line">#0  __GI___libc_res_nquery (statp=statp@entry=0x7ffff7ddc080 &lt;_res@GLIBC_2.2.5&gt;, name=0x400717 &quot;foo.bar.google.com&quot;, class=class@entry=0x1, </div><div class="line">    type=type@entry=0xf371, answer=answer@entry=0x7fffffffda40 &quot;\214\336&quot;, &apos;B&apos; &lt;repeats 198 times&gt;..., anslen=anslen@entry=0x800, </div><div class="line">    answerp=0x7fffffffe2b0, answerp2=0x7fffffffe2a8, nanswerp2=0x7fffffffe2a4, resplen2=0x7fffffffe2a0) at res_query.c:262</div><div class="line">#1  0x00007ffff7419c47 in __libc_res_nquerydomain (statp=statp@entry=0x7ffff7ddc080 &lt;_res@GLIBC_2.2.5&gt;, name=&lt;optimized out&gt;, </div><div class="line">    name@entry=0x400717 &quot;foo.bar.google.com&quot;, domain=&lt;optimized out&gt;, domain@entry=0x0, class=class@entry=0x1, type=type@entry=0xf371, </div><div class="line">    answer=answer@entry=0x7fffffffda40 &quot;\214\336&quot;, &apos;B&apos; &lt;repeats 198 times&gt;..., anslen=0x800, answerp=0x7fffffffe2b0, answerp2=0x7fffffffe2a8, </div><div class="line">    nanswerp2=0x7fffffffe2a4, resplen2=0x7fffffffe2a0) at res_query.c:582</div><div class="line">#2  0x00007ffff7419fbe in __GI___libc_res_nsearch (statp=0x7ffff7ddc080 &lt;_res@GLIBC_2.2.5&gt;, name=name@entry=0x400717 &quot;foo.bar.google.com&quot;, </div><div class="line">    class=class@entry=0x1, type=type@entry=0xf371, answer=answer@entry=0x7fffffffda40 &quot;\214\336&quot;, &apos;B&apos; &lt;repeats 198 times&gt;..., </div><div class="line">    anslen=anslen@entry=0x800, answerp=0x7fffffffe2b0, answerp2=0x7fffffffe2a8, nanswerp2=0x7fffffffe2a4, resplen2=0x7fffffffe2a0)</div><div class="line">    at res_query.c:378</div><div class="line">#3  0x00007ffff762b866 in _nss_dns_gethostbyname4_r (name=0x400717 &quot;foo.bar.google.com&quot;, pat=0x4242424242424242, </div><div class="line">    buffer=0x4242424242424242 &lt;error: Cannot access memory at address 0x4242424242424242&gt;, buflen=0x4242424242424242, errnop=0x7fffffffe8ac, herrnop=0x7fffffffe880, ttlp=0x4242424242424242) at nss_dns/dns-host.c:314</div><div class="line">#4  0x4242424242424242 in ?? ()</div><div class="line">#5  0x4242424242424242 in ?? ()</div><div class="line">#6  0x4242424242424242 in ?? ()</div><div class="line">#7  0x4242424242424242 in ?? ()</div><div class="line">#8  0x4242424242424242 in ?? ()</div><div class="line">#9  0x4242424242424242 in ?? ()</div><div class="line">#10 0x4242424242424242 in ?? ()</div><div class="line">#11 0x4242424242424242 in ?? ()</div><div class="line">#12 0x726c424242424242 in ?? ()</div><div class="line">#13 0x000073726574756f in ?? ()</div><div class="line">#14 0x0000000000000000 in ?? ()</div><div class="line">gdb-peda$</div></pre></td></tr></table></figure>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>从gdb看到的调用栈可以看出，崩溃的调用栈是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">getaddrinfo() 	/sysdeps/posix/getaddrinfo.c</div><div class="line">|</div><div class="line">gaih_inet()		/sysdeps/posix/getaddrinfo.c</div><div class="line">|</div><div class="line">gethostbyname4_r()	/resolv/nss_dns/dns-host.c</div><div class="line">|</div><div class="line">__libc_res_nsearch()	/resolv/res_query.c</div><div class="line">|</div><div class="line">__libc_res_nquerydomain()	/resolv/res_query.c</div><div class="line">|</div><div class="line">__libc_res_nquery()		/resolv/res_query.c</div><div class="line">|</div><div class="line">__libc_res_nsend()		/resolv/res_send.c</div><div class="line">|</div><div class="line">send_dg()	/resolv/res_send.c</div><div class="line">(send_vc()	/resolv/res_send.c)</div></pre></td></tr></table></figure>
<p>其中，我们给<code>getaddrinfo</code>函数传入的hints参数中，其ai_family为AF_UNSPEC，这个参数使得<code>getaddrinfo</code>在后来会调用<code>gethostbyname4_r()</code>来进行IPV4与IPV6的DNS的并发查询。我们要关注的重点就是<code>gethostbyname4_r()</code>、<code>__libc_res_nsend()</code>、<code>send_dg()</code>。漏洞发生在<code>send_dg</code>函数中。</p>
<p>函数调用栈中相关的变量关系大概是这样，我觉得搞明白这些变量的意义对于理解这个洞比较关键，但这些变量命名还是挺乱的，我们之后会逐步理清。另外还有一点是关于DNS的基础也是理解的前题，就是DNS一般来说是使用UDP进行请求与响应的，但是如果数据内容大于512bytes（取决于配置），DNS服务器在返回数据包中将会置位truncated flag，然后client将会重新使用TCP来进行本次DNS请求（当然也可以配置只使用TCP）。</p>
<p><img src="/images/cve_2015_7547_0.png" alt="cve_2015_7547_0.png"></p>
<p>首先，<code>gethostbynamr4_r()</code>首先在栈上用alloca分配了2048 bytes的空间，同时也定义了ans2p、nans2p、resplen2，这几个变量是用于标识第二个数据包（因为我们需要发送IPV4和IPV6两个DNS请求，因此是有两个数据包，如果使用TCP的DNS请求的响应也分为两次回应的话）的在buffer中的位置、buffer大小以及对应response的大小。相关代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">301</span>   <span class="keyword">union</span></div><div class="line"><span class="number">302</span>   &#123;</div><div class="line"><span class="number">303</span>     querybuf *buf;</div><div class="line"><span class="number">304</span>     u_char *ptr;</div><div class="line"><span class="number">305</span>   &#125; host_buffer;</div><div class="line"><span class="number">306</span>   querybuf *orig_host_buffer;</div><div class="line"><span class="number">307</span>   host_buffer.buf = orig_host_buffer = (querybuf *) alloca (<span class="number">2048</span>); </div><div class="line"><span class="number">308</span>   u_char *ans2p = <span class="literal">NULL</span>;</div><div class="line"><span class="number">309</span>   <span class="keyword">int</span> nans2p = <span class="number">0</span>;</div><div class="line"><span class="number">310</span>   <span class="keyword">int</span> resplen2 = <span class="number">0</span>;</div><div class="line"><span class="number">311</span> </div><div class="line"><span class="number">312</span>   <span class="keyword">int</span> olderr = errno;</div><div class="line"><span class="number">313</span>   <span class="keyword">enum</span> nss_status status;</div><div class="line"><span class="number">314</span>   <span class="keyword">int</span> n = __libc_res_nsearch (&amp;_res, name, C_IN, T_UNSPEC,</div><div class="line"><span class="number">315</span>                   host_buffer.buf-&gt;buf, <span class="number">2048</span>, &amp;host_buffer.ptr,</div><div class="line"><span class="number">316</span>                   &amp;ans2p, &amp;nans2p, &amp;resplen2);</div></pre></td></tr></table></figure>
<p>之后一路调用到<code>__libc_res_nsend</code>，这个函数用于调用（或者是反复调用）<code>send_dg</code>（处理UDP数据包的发送与接收）与<code>send_vc</code>（处理TCP数据包的发送与接收）来完成DNS查询，也就是说<code>send_dg</code>和<code>send_vc</code>只负责单次的DNS请求（但是这个单次不一定就是只有一个数据包，根据需要IPV4还是IPV6还是都需要来决定 ，如果都需要就会在一次调用中完成IPV4与IPV6数据的请求与接收），如果出了什么问题比如timeout或者truncated都会直接返回由<code>__libc_res_nsend</code>来决定是否继续发送及使用什么方式发送。</p>
<p>现在我们可以来看<code>send_dg</code>函数中产生漏洞的地方，<code>send_dg</code>函数主要是完成了数据包的发送与接收，漏洞出在接收数据包的代码中，我们可以跳过无关的发送代码。首先是定义了一些局部变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1191</span>         <span class="keyword">int</span> *thisanssizp;</div><div class="line"><span class="number">1192</span>         u_char **thisansp;</div><div class="line"><span class="number">1193</span>         <span class="keyword">int</span> *thisresplenp;</div></pre></td></tr></table></figure>
<p>这三个变量用于标识用于接收当前数据包（IPV4的或IPV6）的buffer信息，分别是buffer大小、buffer指针、response长度。我们当前的情况是需要接收两个数据包，IPV4的查询响应与IPV6的查询响应，当接收第一个包的时候，if条件满足（buf2指向之前要发送的第二个数据包buffer，这里用来判断是否只需要接收一个包即可），进入这一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1194</span> </div><div class="line"><span class="number">1195</span>         <span class="keyword">if</span> ((recvresp1 | recvresp2) == <span class="number">0</span> || buf2 == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="number">1196</span>             thisanssizp = anssizp;</div><div class="line"><span class="number">1197</span>             thisansp = anscp ?: ansp;</div><div class="line"><span class="number">1198</span>             assert (anscp != <span class="literal">NULL</span> || ansp2 == <span class="literal">NULL</span>);</div><div class="line"><span class="number">1199</span>             thisresplenp = &amp;resplen;</div><div class="line"><span class="number">1200</span>         &#125; <span class="keyword">else</span> &#123;</div></pre></td></tr></table></figure>
<p>这一段代码是没有问题的，直接使用了传进来的stack中的2048bytes的buffer去接收数据。但是如果这个2048 bytes的buffer不够，会进入下一段代码使用malloc分配64k的空间进行接收：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">1228</span>         <span class="keyword">if</span> (*thisanssizp &lt; MAXPACKET</div><div class="line"><span class="number">1229</span>             <span class="comment">/* Yes, we test ANSCP here.  If we have two buffers</span></div><div class="line">1230                both will be allocatable.  */</div><div class="line"><span class="number">1231</span>             &amp;&amp; anscp</div><div class="line"><span class="number">1232</span> #ifdef FIONREAD</div><div class="line"><span class="number">1233</span>             &amp;&amp; (ioctl (pfd[<span class="number">0</span>].fd, FIONREAD, thisresplenp) &lt; <span class="number">0</span></div><div class="line"><span class="number">1234</span>             || *thisanssizp &lt; *thisresplenp)</div><div class="line"><span class="number">1235</span> #endif</div><div class="line"><span class="number">1236</span>                     ) &#123;</div><div class="line"><span class="number">1237</span>             u_char *newp = <span class="built_in">malloc</span> (MAXPACKET);</div><div class="line"><span class="number">1238</span>             <span class="keyword">if</span> (newp != <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="number">1239</span>                 *anssizp = MAXPACKET;</div><div class="line"><span class="number">1240</span>                 *thisansp = ans = newp;</div><div class="line"><span class="number">1241</span>             &#125;</div><div class="line"><span class="number">1242</span>         &#125;</div></pre></td></tr></table></figure>
<p>其实单单看这一段代码是没有问题的，从对这个漏洞的patch也可以看出，只不过是换了一个host_buffer的指针去修改host_bufer指向newp，本质上在这里其实并没有什么改变：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-				*anssizp = MAXPACKET;</div><div class="line">-				*thisansp = ans = newp;</div><div class="line">+				*thisanssizp = MAXPACKET;</div><div class="line">+				*thisansp = newp;</div></pre></td></tr></table></figure>
<p>其实问题是这样产生的，从上面给出的变量图可以看到，这里是想要host_buffer指向新的buffer以及修改anssiz来反映这个buffer的大小变化，然后让<code>__libc_res_nsend</code>中的ans依然指向2048bytes因为如果第二个数据包比较小还依然能存在栈中，这个意图没有问题，实际上问题出在下面的关于准备第二个数据包的buffer相关变量中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="number">1200</span>         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">1201</span>             <span class="keyword">if</span> (*anssizp != MAXPACKET) &#123;</div><div class="line"><span class="number">1202</span>                 <span class="comment">/* No buffer allocated for the first</span></div><div class="line">1203                    reply.  We can try to use the rest</div><div class="line">1204                    of the user-provided buffer.  */</div><div class="line"><span class="number">1205</span> #ifdef _STRING_ARCH_unaligned</div><div class="line"><span class="number">1206</span>                 *anssizp2 = orig_anssizp - resplen;</div><div class="line"><span class="number">1207</span>                 *ansp2 = *ansp + resplen;</div><div class="line"><span class="number">1208</span> <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">...					[...]</div><div class="line"><span class="number">1214</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">1215</span>             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">1216</span>                 <span class="comment">/* The first reply did not fit into the</span></div><div class="line">1217                    user-provided buffer.  Maybe the second</div><div class="line">1218                    answer will.  */</div><div class="line"><span class="number">1219</span>                 *anssizp2 = orig_anssizp;</div><div class="line"><span class="number">1220</span>                 *ansp2 = *ansp;</div><div class="line"><span class="number">1221</span>             &#125;</div><div class="line"><span class="number">1222</span> </div><div class="line"><span class="number">1223</span>             thisanssizp = anssizp2;</div><div class="line"><span class="number">1224</span>             thisansp = ansp2;</div><div class="line"><span class="number">1225</span>             thisresplenp = resplen2;</div><div class="line"><span class="number">1226</span>         &#125;</div></pre></td></tr></table></figure>
<p>问题是出在关于orig_anssizp变量的处理上，这个变量是在<code>send_dg</code>一开始这样赋值的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1000</span>     <span class="keyword">int</span> orig_anssizp = *anssizp;</div></pre></td></tr></table></figure>
<p>结合第二个数据包的buffer准备就可以看到问题了，本来用来标识64k的heap中的buffer大小的变量却被用来标志2048bytes的栈buffer的大小，然后传递给<code>recvfrom</code>来接受数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1246</span>         *thisresplenp = recvfrom(pfd[<span class="number">0</span>].fd, (<span class="keyword">char</span>*)*thisansp,</div><div class="line"><span class="number">1247</span>                      *thisanssizp, <span class="number">0</span>,</div><div class="line"><span class="number">1248</span>                     (<span class="keyword">struct</span> sockaddr *)&amp;from, &amp;fromlen);</div></pre></td></tr></table></figure>
<p>这个时候一旦接个大的数据包就有问题了，stack-overflow就产生了。从patch中也可以证明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-	<span class="keyword">int</span> orig_anssizp = *anssizp;</div></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@@ <span class="number">-1154</span>,<span class="number">50</span> +<span class="number">1123</span>,<span class="number">48</span> @@ send_dg(res_state statp,</div><div class="line"> 			assert (anscp != <span class="literal">NULL</span> || ansp2 == <span class="literal">NULL</span>);</div><div class="line"> 			thisresplenp = &amp;resplen;</div><div class="line"> 		&#125; <span class="keyword">else</span> &#123;</div><div class="line">-			<span class="keyword">if</span> (*anssizp != MAXPACKET) &#123;</div><div class="line">-				<span class="comment">/* No buffer allocated for the first</span></div><div class="line">-				   reply.  We can try to use the rest</div><div class="line">-				   of the user-provided buffer.  */</div><div class="line">-#<span class="keyword">if</span> _STRING_ARCH_unaligned</div><div class="line">-				*anssizp2 = orig_anssizp - resplen;</div><div class="line">-				*ansp2 = *ansp + resplen;</div><div class="line">-#<span class="keyword">else</span></div><div class="line">-				<span class="keyword">int</span> aligned_resplen</div><div class="line">-				  = ((resplen + __alignof__ (HEADER) - <span class="number">1</span>)</div><div class="line">-				     &amp; ~(__alignof__ (HEADER) - <span class="number">1</span>));</div><div class="line">-				*anssizp2 = orig_anssizp - aligned_resplen;</div><div class="line">-				*ansp2 = *ansp + aligned_resplen;</div><div class="line">-#endif</div><div class="line">-			&#125; <span class="keyword">else</span> &#123;</div><div class="line">-				<span class="comment">/* The first reply did not fit into the</span></div><div class="line">-				   user-provided buffer.  Maybe the second</div><div class="line">-				   answer will.  */</div><div class="line">-				*anssizp2 = orig_anssizp;</div><div class="line">-				*ansp2 = *ansp;</div><div class="line">-			&#125;</div><div class="line">-</div><div class="line"> 			thisanssizp = anssizp2;</div><div class="line"> 			thisansp = ansp2;</div><div class="line"> 			thisresplenp = resplen2;</div><div class="line"> 		&#125;</div></pre></td></tr></table></figure>
<p>可以看出patch的主要思路就是直接删除了在接受第二个数据包的时候对于栈上的buffer的考虑。</p>
<p><code>send_vc</code>中接受数据包的buffer处理基本和<code>send_dg</code>相同。所以我们也就可以理清POC中的利用思路，首先先是UDP请求IPV4和IPV6的DNS响应，然后服务器返回一个较大的响应包并设置truncated flag，这个时候send_dg中接受到这个包看到TC标志就立刻设置相关变量并返回使得<code>__libc_res_nsend</code>使用<code>send_vc</code>继续（所以我觉得POC中的等到接受到再一次的TCP请求再将之前的UDP包返回来我是没搞明白其意义，这个时候client应该不会再理会这第二个UDP响应了，我尝试修改poc试了一下也确实没有问题，难道poc中这么做只是为了避免client可能的等待？），然后由于orig_anssizp的关系，第一个数据包使用栈中的buffer接受了，但是第二个大数据包到来的时候因为orig_anssizp太大而计算size错误导致了溢出。</p>
<h2 id="还有一些"><a href="#还有一些" class="headerlink" title="还有一些"></a>还有一些</h2><p>这个漏洞并不止google给出的POC中的一种触发姿势，只要能够先让malloc发生，然后立刻返回再send一次让orig_anssizp被改为64k就可以。比如也可以使用timeout的方式来完成。</p>
<p>但是POC离对这个CVE的RCE还有些距离，虽然没有canary，但除了要过ASLR和NX保护以外，还要过一些check，在<code>gethostbyname4_r</code>返回前，host_buffer和ans2p这两个变量会被检查是否为null然后交给<code>free()</code>，所以这里是个问题，但也不是不可能的，在特定场景下或者搭配其他漏洞应该是可以过去的，这里还需要进一步折腾。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/12/04/cve_2015_3636/" class="prev">PREV</a><a href="/2016/10/25/android_debug_analysis/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://a7vinx.github.io">Arvin.X</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>